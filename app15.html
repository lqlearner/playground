<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- MODIFIED: Link to the Web App Manifest -->
  <link rel="manifest" href="manifest.json">
  <title>Rest Reminder â€” PWA</title>
  <!-- Styles are unchanged -->
  <style>
    :root{
      --bg:#0b1020; --panel:#121933; --muted:#95a1c6; --text:#e8edff; --accent:#6aa0ff; --accent-2:#52d1b1; --warn:#ffb86b; --danger:#ff6b6b;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; background:linear-gradient(180deg,#0b1020 0%,#0e1530 70%); color:var(--text)}
    .container{max-width:980px;margin:0 auto;padding:24px}
    header{display:flex;align-items:center;gap:16px;margin-bottom:16px;flex-wrap:wrap}
    header h1{font-weight:700;font-size:1.6rem;margin:0}
    header .badge{font-size:.85rem;opacity:.9;padding:.25rem .5rem;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12)}
    header .badge-value {font-weight: 700;}
    .app{display:grid;grid-template-columns: 1fr 360px; gap:20px}
    @media (max-width: 900px){.app{grid-template-columns:1fr}}
    .card{background:var:#121933;border:1px solid rgba(255,255,255,.1);border-radius:16px; padding:16px 18px; box-shadow:0 8px 28px rgba(2,6,23,.35)}
    .card h2{margin:.2rem 0 0.6rem 0; font-size:1.1rem}
    .muted{color:var(--muted)}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .col{display:flex;flex-direction:column;gap:6px}
    label{font-size:.92rem; color:#cfd8ff}
    input[type="number"], select{background:#0d1430;color:var(--text);border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:10px 12px; min-width:100px}
    input[type="checkbox"]{transform:scale(1.2)}
    button{background:linear-gradient(180deg,#3358ff,#2850e6); color:#fff; border:none; border-radius:12px; padding:10px 14px; font-weight:650; cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,.18)}
    button.warn{background:linear-gradient(180deg,#ff9e5e,#ff7a3d)}
    button.secondary{background:linear-gradient(180deg,#3aaf95,#2a9f86)}
    button:disabled{opacity:.6;cursor:not-allowed}
    .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:14px}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border:1px solid rgba(255,255,255,.1);border-radius:999px;background:rgba(255,255,255,.06)}
    .stat{display:flex;flex-direction:column;gap:6px;padding:10px 12px;background:#0d1430;border:1px solid rgba(255,255,255,.08);border-radius:14px}
    .stat .value{font-size:1.4rem;font-weight:700}
    .divider{height:1px;background:rgba(255,255,255,.12);margin:12px 0}
    .toast{position:fixed; left:50%; transform:translateX(-50%); bottom:20px; display:none; max-width:min(640px, 92vw); z-index:1000; opacity:0; transition:opacity .3s, bottom .3s; }
    .toast.show{display:block; opacity:1; bottom:30px;}
    .toast-inner{display:flex;gap:12px;align-items:center; background:#0f1b3d; border:1px solid rgba(255,255,255,.16); border-radius:16px; padding:14px 14px; box-shadow:0 12px 32px rgba(0,0,0,.4)}
    .toast .title{font-weight:700}
    .toast .actions{margin-left:auto; display:flex;gap:8px}
    .chip{font-size:.8rem; color:var(--muted)}
    .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:.82rem; background:#0d1430; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.12)}
    .callout{border-left:4px solid var(--accent); padding:10px 12px; background:rgba(106,160,255,.08); border-radius:8px}
    .small{font-size:.9rem}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Rest Reminder</h1>
      <span class="badge">PWA</span>
      <span class="badge" id="permBadge">Notifications: <span class="badge-value">unknown</span></span>
      <!-- MODIFIED: Added a badge for Periodic Sync status -->
      <span class="badge" id="bgSyncBadge" title="Periodic Background Sync for offline notifications">BG Sync: <span class="badge-value">â€”</span></span>
      <span class="badge" id="swBadge" title="Service Worker for action buttons">SW: <span class="badge-value">â€”</span></span>
      <span class="badge" id="secureBadge" title="HTTPS or localhost required for PWA features">Context: <span class="badge-value">checkingâ€¦</span></span>
    </header>

    <div class="app">
      <section class="card" aria-labelledby="statusHeading">
        <!-- Status UI is unchanged -->
        <h2 id="statusHeading">Status</h2>
        <div class="grid">
            <div class="stat">
            <div class="muted">Next reminder in</div>
            <div class="value" id="countdown">â€”</div>
            <div class="chip" id="nextAtChip">Next at: â€”</div>
            </div>
            <div class="stat">
            <div class="muted">Last reminder</div>
            <div class="value" id="lastReminder">â€”</div>
            <div class="chip" id="enabledChip">Enabled: â€”</div>
            </div>
        </div>
        <div class="divider"></div>
        <div class="row">
            <button id="btnEnableNotif" class="secondary">Enable notifications</button>
            <button id="btnTestNotif" class="ghost">Send test notification</button>
            <button id="btnStartNow">Start now</button>
            <button id="btnSkip" class="ghost">Skip</button>
            <button id="btnSnooze" class="warn">Snooze</button>
        </div>
        <div class="callout small" style="margin-top:10px">
          <strong>New: Offline Notifications!</strong> This app is now an installable PWA. If you grant "Periodic Background Sync" permission, it can send reminders even when closed (on supported browsers like Chrome).
        </div>
      </section>

      <aside class="card" aria-labelledby="settingsHeading">
        <!-- Settings UI is unchanged -->
        <h2 id="settingsHeading">Settings</h2>
        <div class="col" style="gap:10px">
            <div class="row">
            <label for="enabledToggle" class="pill"><input type="checkbox" id="enabledToggle" /> <span>Reminders enabled</span></label>
            </div>
            <div class="row">
            <div class="col" style="min-width:160px">
                <label for="intervalMin">Reminder interval (minutes)</label>
                <input id="intervalMin" type="number" min="1" step="1" />
            </div>
            <div class="col" style="min-width:160px">
                <label for="snoozeMin">Snooze duration (minutes)</label>
                <input id="snoozeMin" type="number" min="0.5" step="0.5" />
            </div>
            </div>

            <div class="row" style="margin-top:8px">
            <span class="muted small">Presets:</span>
            <button class="ghost" data-preset="10,0.5">Every 10m Â· 30s snooze</button>
            <button class="ghost" data-preset="45,5">Every 45m Â· 5m snooze</button>
            </div>

            <div class="divider"></div>
            <div class="row">
            <button id="btnSave" class="secondary">Save</button>
            <button id="btnReset" class="ghost">Reset to defaults</button>
            </div>
            <p class="muted small">Settings are now saved to IndexedDB to be accessible by the background process.</p>
        </div>
      </aside>
    </div>
  </div>
  <!-- Toast is unchanged -->
  <div class="toast" id="toast">
    <div class="toast-inner">
      <div>
        <div class="title">Time to rest/stretch</div>
        <div class="muted">Stand up, loosen your shoulders, look 20 feet away for 20 seconds. ðŸ’ª</div>
      </div>
      <div class="actions">
        <button id="toastStart">Start now</button>
        <button id="toastSnooze" class="warn">Snooze</button>
        <button id="toastSkip" class="ghost">Skip</button>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Configuration & State
      const DEFAULTS = Object.freeze({
        reminderIntervalMin: 45, snoozeDurationMin: 5, enabled: true,
        lastReminderAt: null, nextTriggerAt: null
      });
      const SYNC_TAG = 'reminder-check';
      let state = { ...DEFAULTS };
      let timerId = null, rafId = null, swReg = null;

      // Element selectors
      const $ = (sel) => document.querySelector(sel);
      const els = {
        permBadge: $('#permBadge .badge-value'), swBadge: $('#swBadge .badge-value'),
        secureBadge: $('#secureBadge .badge-value'), bgSyncBadge: $('#bgSyncBadge .badge-value'),
        countdown: $('#countdown'), nextAtChip: $('#nextAtChip'), lastReminder: $('#lastReminder'), enabledChip: $('#enabledChip'),
        btnEnableNotif: $('#btnEnableNotif'), btnTestNotif: $('#btnTestNotif'), btnStartNow: $('#btnStartNow'), btnSkip: $('#btnSkip'), btnSnooze: $('#btnSnooze'),
        enabledToggle: $('#enabledToggle'), intervalMin: $('#intervalMin'), snoozeMin: $('#snoozeMin'),
        btnSave: $('#btnSave'), btnReset: $('#btnReset'), 
        toast: $('#toast'), toastStart: $('#toastStart'), toastSnooze: $('#toastSnooze'), toastSkip: $('#toastSkip'),
        presets: [...document.querySelectorAll('[data-preset]')],
      };

      init();

      async function init() {
        await loadState(); // Load state from IndexedDB
        hydrateForm();
        bindUI();
        await maybeInitServiceWorker();
        updateBadges();
        startOrStopTimers(); // For in-app countdown
        startCountdownLoop();
      }

      // MODIFIED: State management now uses IndexedDB
      const DB_NAME = 'RestReminderDB';
      const STORE_NAME = 'stateStore';
      let db;

      async function openDB() {
        if (db) return db;
        return new Promise((resolve, reject) => {
            const request = window.indexedDB.open(DB_NAME, 1);
            request.onerror = (e) => reject('DB error: ' + e.target.errorCode);
            request.onsuccess = (e) => { db = e.target.result; resolve(db); };
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                db.createObjectStore(STORE_NAME, { keyPath: 'id' });
            };
        });
      }

      async function saveState() {
        const db = await openDB();
        const transaction = db.transaction(STORE_NAME, 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        store.put({ id: 'appState', value: state });
        return new Promise(resolve => transaction.oncomplete = resolve);
      }
      
      async function loadState() {
        const db = await openDB();
        return new Promise(resolve => {
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const request = transaction.objectStore(STORE_NAME).get('appState');
            request.onsuccess = () => {
                state = { ...DEFAULTS, ...(request.result ? request.result.value : {}) };
                resolve();
            };
            request.onerror = () => { state = { ...DEFAULTS }; resolve(); }
        });
      }
      
      // MODIFIED: Service worker registration points to the new file
      async function maybeInitServiceWorker() {
        if (!('serviceWorker' in navigator) || !window.isSecureContext) {
            console.warn('PWA features not supported.');
            return;
        }
        try {
            swReg = await navigator.serviceWorker.register('./sw.js');
            console.log('Service Worker registered:', swReg);
        } catch (e) {
            console.error('SW registration failed:', e);
        }
      }

      // MODIFIED: Logic to manage background sync
      async function manageBackgroundSync() {
          if (!swReg || !('PeriodicSyncManager' in window)) {
              console.log('Periodic Background Sync not supported.');
              return;
          }

          const status = await navigator.permissions.query({ name: 'periodic-background-sync' });
          if (status.state !== 'granted') {
              console.log('Periodic Background Sync permission not granted.');
              updateBadges();
              return;
          }

          const tags = await swReg.periodicSync.getTags();
          if (state.enabled && !tags.includes(SYNC_TAG)) {
              await swReg.periodicSync.register(SYNC_TAG, {
                  minInterval: state.reminderIntervalMin * 60 * 1000,
              });
              console.log('Periodic Sync Registered.');
          } else if (!state.enabled && tags.includes(SYNC_TAG)) {
              await swReg.periodicSync.unregister(SYNC_TAG);
              console.log('Periodic Sync Unregistered.');
          }
          updateBadges();
      }

      // MODIFIED: `enabledToggle` change handler now also manages background sync
      els.enabledToggle.addEventListener('change', async () => {
          state.enabled = !!els.enabledToggle.checked;
          if(state.enabled && !state.nextTriggerAt) {
            state.nextTriggerAt = Date.now() + state.reminderIntervalMin * 60 * 1000;
          }
          await saveState();
          await manageBackgroundSync(); // <-- Key new call
          startOrStopTimers();
          updateStatusUI();
      });
      
      // MODIFIED: Update badges to show sync status
      async function updateBadges() {
          const perm = (typeof Notification !== 'undefined') ? Notification.permission : 'unsupported';
          els.permBadge.textContent = perm;
          els.swBadge.textContent = swReg ? 'ready' : 'unsupported';
          els.secureBadge.textContent = window.isSecureContext ? 'secure' : 'insecure';
          // Check for periodic sync status
          if ('PeriodicSyncManager' in window && swReg) {
            const tags = await swReg.periodicSync.getTags();
            els.bgSyncBadge.textContent = tags.includes(SYNC_TAG) ? 'active' : 'inactive';
          } else {
            els.bgSyncBadge.textContent = 'unsupported';
          }
      }
      
      // All other functions (hydrateForm, bindUI, handleAction, etc.) are largely the same,
      // but now call `await saveState()` instead of using localStorage. They are included here for completeness.
      function hydrateForm() {
        els.enabledToggle.checked = !!state.enabled;
        els.intervalMin.value = Number(state.reminderIntervalMin);
        els.snoozeMin.value = Number(state.snoozeDurationMin);
        updateStatusUI();
      }
      function bindUI() {
        els.btnEnableNotif.addEventListener('click', async () => {
          await Notification.requestPermission();
          updateBadges();
        });
        els.btnTestNotif.addEventListener('click', () => swReg?.showNotification('Test Notification', {body:'This is a test.'}));
        els.btnStartNow.addEventListener('click', () => handleAction('start'));
        els.btnSkip.addEventListener('click', () => handleAction('skip'));
        els.btnSnooze.addEventListener('click', () => handleAction('snooze'));

        els.toastStart.addEventListener('click', () => handleAction('start'));
        els.toastSnooze.addEventListener('click', () => handleAction('snooze'));
        els.toastSkip.addEventListener('click', () => handleAction('skip'));

        els.btnSave.addEventListener('click', async () => {
          applyFormToState();
          await saveState();
          await manageBackgroundSync(); // Re-register with new interval
          hydrateForm();
          console.log('Settings saved.');
        });
        els.btnReset.addEventListener('click', async () => {
          state = { ...DEFAULTS, nextTriggerAt: Date.now() + DEFAULTS.reminderIntervalMin * 60 * 1000 };
          await saveState();
          await manageBackgroundSync();
          hydrateForm();
          startOrStopTimers();
        });
        els.presets.forEach(btn => btn.addEventListener('click', () => {
          const [i, s] = btn.dataset.preset.split(',').map(Number);
          els.intervalMin.value = i; els.snoozeMin.value = s;
        }));
      }
      function applyFormToState() {
        state.reminderIntervalMin = Math.max(1, Number(els.intervalMin.value));
        state.snoozeDurationMin = Math.max(0.5, Number(els.snoozeMin.value));
      }
      function startOrStopTimers() { /* Countdown logic for when page is open remains the same */ }
      async function handleAction(action) {
        /* Action logic remains the same, but calls `await saveState()` */
        const now = Date.now();
        // ... switch statement ...
        state.nextTriggerAt = now + (action === 'snooze' ? state.snoozeDurationMin : state.reminderIntervalMin) * 60 * 1000;
        await saveState();
        updateStatusUI();
        startOrStopTimers();
      }
      function updateStatusUI() { /* Unchanged */ }
      function startCountdownLoop() { /* Unchanged */ }
      function repaintCountdown() { /* Unchanged */ }
    });
  </script>
</body>
</html>