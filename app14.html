<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dictation App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/16.1.1/lib/marked.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lucide@latest/dist/umd/lucide.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <script src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    <!-- ADDED: LZ-String library for compression from app10 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
    <style>
      :root {
        --primary-color: #6366f1;
        --accent-color: #f97316;
        --success-color: #10b981;
        --danger-color: #ef4444;
        --gray-light: #f3f4f6;
        --gray-dark: #374151;
      }

      body {
        margin: 0;
        font-family: 'Inter', sans-serif;
        background: var(--gray-light);
        color: var(--gray-dark);
      }

      .app-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        padding: 40px 24px;
        min-height: 100vh;
      }

      .note-area {
        background: #fff;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
        max-width: 960px;
        width: 100%;
        padding: 32px;
        margin-bottom: 32px;
      }

      .editor-title {
        font-size: 2rem;
        font-weight: 600;
        border: none;
        padding: 16px;
        background: #f1f5f9;
        border-radius: 12px;
        margin-bottom: 24px;
      }

      .tab-navigation {
        display: flex;
        border-bottom: 2px solid #e5e7eb;
        margin-bottom: 12px;
      }

      .tab-button {
        flex: 1;
        padding: 12px;
        font-weight: 500;
        background: none;
        border: none;
        cursor: pointer;
        color: #6b7280;
        transition: all 0.3s;
        position: relative;
      }

      .tab-button.active {
        color: var(--primary-color);
        font-weight: 600;
      }

      .tab-button.active::after {
        content: '';
        position: absolute;
        left: 0;
        bottom: 0;
        width: 100%;
        height: 3px;
        background-color: var(--primary-color);
      }

      .note-content-wrapper {
        display: flex;
        flex-direction: column;
      }

      .note-content {
        display: none;
        background: #f9fafb;
        border: 1px solid #e5e7eb;
        padding: 20px;
        border-radius: 12px;
        min-height: 260px;
        white-space: pre-wrap;
        max-height: calc(1.5em * 20); /* 1.5em line-height √ó 20 lines */
        overflow-y: auto;
        line-height: 1.5em;
      }

      .note-content.active {
        display: block;
      }

      .note-content-wrapper > div > button {
        display: none;
      }

      .recording-interface {
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
        margin-top: 24px;
      }

      .record-button {
        background-color: var(--danger-color);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 12px;
        font-size: 16px;
        cursor: pointer;
        transition: background 0.3s ease;
      }

      .record-button:hover {
        background-color: #dc2626;
      }

      .record-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .api-key-input {
        width: 100%;
        max-width: 480px;
        padding: 12px;
        font-size: 14px;
        border-radius: 10px;
        border: 1px solid #d1d5db;
        background-color: #fff;
      }

      #saveApiKeyButton {
        background-color: var(--success-color);
        margin-left: 12px;
        padding: 12px 20px;
        border-radius: 10px;
        font-weight: 500;
      }

      #saveApiKeyButton:hover {
        background-color: #059669;
      }

      #waveform {
        width: 100%;
        height: 60px;
        background: #e5e7eb;
        border-radius: 12px;
        margin-top: 24px;
      }

      .debug-panel {
        margin-top: 20px;
        color: #9ca3af;
        font-size: 13px;
      }

      #apiKeyReminder {
        color: #9ca3af;
        font-style: italic;
        font-size: 13px;
      }

      .min-h-\[150px\] {
        min-height: 150px;
      }
      .relative {
        position: relative;
      }
      .absolute {
        position: absolute;
      }
      .top-2 {
        top: 0.5rem;
      }
      .right-2 {
        right: 0.5rem;
      }

      /* Toastify custom styles */
      .toastify {
        font-family: 'Inter', sans-serif;
      }
    </style>
  </head>
  <body class="bg-gray-100 min-h-screen flex items-center justify-center">
    <div class="container mx-auto p-4">
      <div class="bg-white shadow-lg rounded-lg p-6 max-w-4xl mx-auto">
        <h1 class="text-2xl font-bold text-gray-800 mb-6">Dictation App</h1>
        <!-- API Key Management -->
        <div class="mb-6">
          <h2 class="text-lg font-semibold text-gray-700 mb-2">API Key Management</h2>
          <div class="flex space-x-2">
            <input id="apiKeyInput" type="password" placeholder="Enter Google Gemini API Key"
              class="flex-1 p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" />
            <button id="saveApiKeyButton"
              class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600">Save Key</button>
          </div>
          <p id="apiKeyReminder" style="display:none;" class="text-sm text-gray-400 mt-1">Please enter your API Key to enable recording.</p>
        </div>
        <!-- Recording Module -->
        <div class="mb-6">
          <h2 class="text-lg font-semibold text-gray-700 mb-2">Record Screen Audio</h2>
          <div class="flex space-x-4 mb-4">
            <button id="recordButton"
              class="px-4 py-2 rounded-md text-white bg-blue-500 hover:bg-blue-600">Start Screen Share</button>
            <button id="stopButton"
              class="px-4 py-2 rounded-md text-white bg-red-500 hover:bg-red-600" style="display:none;">Stop Recording</button>
            <div class="flex items-center space-x-2">
              <label for="intervalInput" class="text-sm text-gray-700">Chunk (sec):</label>
              <input id="intervalInput" type="number" min="2" max="60" value="10" class="w-16 p-1 border rounded text-sm" />
            </div>
          </div>
          <canvas id="waveform" class="w-full h-24 bg-gray-100 rounded-md" style="display:none;"></canvas>
        </div>
        <!-- Transcription View -->
        <div>
          <h2 class="text-lg font-semibold text-gray-700 mb-2">Transcription</h2>
          <div class="flex space-x-4 mb-4">
            <button id="tabRaw"
              class="px-4 py-2 rounded-md bg-blue-500 text-white">Raw</button>
            <button id="tabPolished"
              class="px-4 py-2 rounded-md bg-gray-200 text-gray-700">Polished</button>
            <button id="polishButton"
              class="px-4 py-2 rounded-md bg-orange-500 text-white hover:bg-orange-600">Polish</button>
          </div>
          <div class="p-4 bg-gray-50 rounded-md min-h-[150px] relative">
            <div id="rawTranscription" class="note-content" contenteditable="true" style="display:block;"></div>
            <button id="copyRaw"
              class="absolute top-2 right-2 px-1.5 py-0.5 text-xs bg-blue-500 text-white rounded hover:bg-blue-600" style="display:none;">Copy</button>
            <div id="polishedNote" class="note-content" contenteditable="true" style="display:none;"></div>
            <button id="copyPolished"
              class="absolute top-2 right-2 px-1.5 py-0.5 text-xs bg-blue-500 text-white rounded hover:bg-blue-600" style="display:none;">Copy</button>
          </div>
          <p id="copyStatus" class="text-green-500 mt-2" style="display:none;"></p>
        </div>

        <!-- ADDED: Meeting Notes Section from app10.html -->
        <div class="mt-8">
          <h2 class="text-lg font-semibold mb-2">Meeting Notes</h2>
          <button id="exportAllNotesBtn" class="px-3 py-1 bg-blue-500 text-white rounded mb-2">Export All Notes</button>
          <ul id="meetingNotesList" class="mb-4"></ul>
          <button id="addNoteBtn" class="px-3 py-1 bg-green-500 text-white rounded">Add New Note</button>
        </div>

      </div>
    </div>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- MERGED: meetingNotes.js logic from app10 is now in a script tag with compression/decompression -->
    <script>
        const NOTES_STORAGE_KEY = 'meetingNotes_compressed'; // Use a new key to avoid conflicts with old data

        /**
         * Loads and decompresses notes from Local Storage.
         * @returns {Array} An array of note objects.
         */
        function loadMeetingNotes() {
            const compressedNotes = localStorage.getItem(NOTES_STORAGE_KEY);
            if (!compressedNotes) {
                return [];
            }
            try {
                // Decompress the string, which might be null if the key is invalid
                const decompressedJSON = LZString.decompressFromUTF16(compressedNotes);
                if (!decompressedJSON) {
                    console.error("Decompression failed or returned empty string. Clearing invalid data.");
                    localStorage.removeItem(NOTES_STORAGE_KEY); // Clear invalid data
                    return [];
                }
                // Parse the decompressed JSON string
                return JSON.parse(decompressedJSON);
            } catch (error) {
                console.error("Error loading or decompressing meeting notes:", error);
                // If decompression or parsing fails, return an empty array to prevent app crash
                return [];
            }
        }

        /**
         * Compresses and saves an array of all notes to Local Storage.
         * @param {Array} notes - The array of note objects to save.
         */
        function saveAllNotes(notes) {
            try {
                const jsonNotes = JSON.stringify(notes);
                const compressedNotes = LZString.compressToUTF16(jsonNotes);
                localStorage.setItem(NOTES_STORAGE_KEY, compressedNotes);
            } catch (error) {
                console.error("Error compressing or saving meeting notes:", error);
                Toastify({ text: "Failed to save notes due to a compression error.", duration: 3000, gravity: "top", position: "center", backgroundColor: "#ef4444" }).showToast();
            }
        }


        /**
         * Saves or updates a single note, then saves the entire compressed collection.
         * @param {Object} noteData - The note object to save or update.
         */
        function saveOrUpdateNote(noteData) {
            let notes = loadMeetingNotes();
            const existingNoteIndex = notes.findIndex(note => note.id === noteData.id);

            if (existingNoteIndex > -1) {
                // Update existing note by merging new data
                notes[existingNoteIndex] = { ...notes[existingNoteIndex], ...noteData };
            } else {
                // Add new note
                notes.push(noteData);
            }

            saveAllNotes(notes);
            Toastify({ text: "Note saved successfully!", duration: 2000, gravity: "top", position: "center", backgroundColor: "#10b981" }).showToast();
        }


        /**
         * Deletes a note by its ID and saves the updated collection.
         * @param {string} noteId - The ID of the note to delete.
         */
        function deleteNote(noteId) {
            let notes = loadMeetingNotes();
            const updatedNotes = notes.filter(note => note.id !== noteId);
            saveAllNotes(updatedNotes);
        }

        /**
         * Exports a single note as a JSON file.
         * @param {string} noteId - The ID of the note to export.
         */
        function exportNote(noteId) {
            const notes = loadMeetingNotes(); // Gets decompressed notes
            const noteToExport = notes.find(note => note.id === noteId);
            if (noteToExport) {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(noteToExport, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", `note_${noteToExport.title || noteToExport.id}.json`);
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
                Toastify({ text: "Note exported.", duration: 2000, gravity: "top", position: "center", backgroundColor: "#6366f1" }).showToast();
            }
        }

        /**
         * Exports all notes as a single JSON file.
         */
        function exportAllNotes() {
            const notes = loadMeetingNotes(); // Gets decompressed notes
            if (notes.length === 0) {
                Toastify({ text: "No notes to export.", duration: 2000, gravity: "top", position: "center", backgroundColor: "#ef4444" }).showToast();
                return;
            }
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(notes, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "all_meeting_notes.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            Toastify({ text: "All notes exported.", duration: 2000, gravity: "top", position: "center", backgroundColor: "#6366f1" }).showToast();
        }

        /**
         * Copies the polished note content to the clipboard.
         * @param {string} noteId - The ID of the note to copy.
         */
        function copyPolishedNote(noteId) {
          const notes = loadMeetingNotes();
          const note = notes.find(n => n.id === noteId);
          if (note && note.polishedNote) {
            navigator.clipboard.writeText(note.polishedNote).then(() => {
              Toastify({ text: "Polished note copied to clipboard!", duration: 2000, gravity: "top", position: "center", backgroundColor: "#6366f1" }).showToast();
            }).catch(err => {
              console.error("Failed to copy text: ", err);
              Toastify({ text: "Failed to copy text.", duration: 2000, gravity: "top", position: "center", backgroundColor: "#ef4444" }).showToast();
            });
          } else {
            Toastify({ text: "No polished note content to copy.", duration: 2000, gravity: "top", position: "center", backgroundColor: "#ef4444" }).showToast();
          }
        }
    </script>
    <script>
      const MODEL_NAME = "gemini-1.5-flash"; // Matched from app10 for consistency
      const polishedNote = document.getElementById("polishedNote");
      const rawTranscription = document.getElementById("rawTranscription");
      const recordBtn = document.getElementById("recordButton");
      const stopBtn = document.getElementById("stopButton");
      const waveform = document.getElementById("waveform");
      const canvasCtx = waveform.getContext("2d");
      const apiKeyInput = document.getElementById("apiKeyInput");
      const saveApiKeyButton = document.getElementById("saveApiKeyButton");
      const copyPolishedButton = document.getElementById("copyPolished");
      const copyRawButton = document.getElementById("copyRaw");
      const tabRaw = document.getElementById("tabRaw");
      const tabPolished = document.getElementById("tabPolished");
      const copyStatus = document.getElementById("copyStatus");
      const intervalInput = document.getElementById("intervalInput");
      const polishButton = document.getElementById("polishButton");

      let mediaRecorder;
      let audioChunks = [];
      let audioContext;
      let analyserNode;
      let source;
      let stream;
      let animationId;
      let dataArray; // Declared for waveform
      let chunkInterval = 10; // seconds
      let chunkTimer = null;
      let isChunkRecording = false;
      let currentPolishedMarkdown = ''; // ADDED: To hold polished text for saving

      function checkApiKey() {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
          recordBtn.disabled = true;
          recordBtn.textContent = "Enter API Key First";
          recordBtn.style.backgroundColor = "gray";
          apiKeyReminder.style.display = "inline";
          return false;
        } else {
          recordBtn.disabled = false;
          recordBtn.textContent = "Start Screen Share";
          recordBtn.style.backgroundColor = "#3b82f6";
          apiKeyReminder.style.display = "none";
          return true;
        }
      }

      apiKeyInput.addEventListener("input", checkApiKey);

      function encryptApiKey(apiKey) {
        return btoa(apiKey);
      }

      function decryptApiKey(encryptedApiKey) {
        return atob(encryptedApiKey);
      }

      saveApiKeyButton.addEventListener("click", () => {
        const apiKey = apiKeyInput.value.trim();
        if (apiKey) {
          const encryptedApiKey = encryptApiKey(apiKey);
          localStorage.setItem("Dict_BARKEY", encryptedApiKey); // Using original key from app14
          Toastify({
            text: "API Key saved and encrypted!",
            duration: 2500,
            gravity: "top",
            position: "center",
            backgroundColor: "#10b981",
            stopOnFocus: true,
          }).showToast();
        } else {
          Toastify({
            text: "Please enter an API key to save.",
            duration: 2500,
            gravity: "top",
            position: "center",
            backgroundColor: "#ef4444",
            stopOnFocus: true,
          }).showToast();
        }
      });
      
      function copyToClipboard(text) {
        navigator.clipboard.writeText(text)
          .then(() => {
            Toastify({
              text: "Text copied to clipboard!",
              duration: 2000,
              gravity: "top",
              position: "center",
              backgroundColor: "#6366f1",
              stopOnFocus: true, 
            }).showToast();
          })
          .catch(err => {
            console.error("Failed to copy text: ", err);
            Toastify({
              text: "Failed to copy text to clipboard.",
              duration: 2000,
              gravity: "top",
              position: "center",
              backgroundColor: "#ef4444",
              stopOnFocus: true,
            }).showToast();
          });
      }

      window.addEventListener("load", () => {
        const encryptedApiKey = localStorage.getItem("Dict_BARKEY");
        if (encryptedApiKey) {
          const decryptedApiKey = decryptApiKey(encryptedApiKey);
          apiKeyInput.value = decryptedApiKey;
          checkApiKey(); 
          Toastify({
            text: "API Key loaded and decrypted!",
            duration: 2500,
            gravity: "top",
            position: "center",
            backgroundColor: "#6366f1",
            stopOnFocus: true,
          }).showToast();
        }
        renderMeetingNotesList(); // ADDED: Initial render on page load
      });

      function updateTabs() {
        if (tabRaw.classList.contains("bg-blue-500")) {
          rawTranscription.style.display = "block";
          copyRawButton.style.display = rawTranscription.textContent.trim() ? "block" : "none";
          polishedNote.style.display = "none";
          copyPolishedButton.style.display = "none";
        } else {
          rawTranscription.style.display = "none";
          copyRawButton.style.display = "none";
          polishedNote.style.display = "block";
          copyPolishedButton.style.display = polishedNote.textContent.trim() ? "block" : "none";
        }
      }

      tabRaw.addEventListener("click", () => {
        tabRaw.classList.add("bg-blue-500", "text-white");
        tabRaw.classList.remove("bg-gray-200", "text-gray-700");
        tabPolished.classList.remove("bg-blue-500", "text-white");
        tabPolished.classList.add("bg-gray-200", "text-gray-700");
        updateTabs();
      });

      tabPolished.addEventListener("click", () => {
        tabPolished.classList.add("bg-blue-500", "text-white");
        tabPolished.classList.remove("bg-gray-200", "text-gray-700");
        tabRaw.classList.remove("bg-blue-500", "text-white");
        tabRaw.classList.add("bg-gray-200", "text-gray-700");
        updateTabs();
      });

      function showCopyStatus(msg) {
        copyStatus.textContent = msg;
        copyStatus.style.display = "block";
        setTimeout(() => copyStatus.style.display = "none", 2000);
      }
      copyRawButton.addEventListener("click", () => {
        navigator.clipboard.writeText(rawTranscription.textContent).then(() => {
          showCopyStatus("Text copied to clipboard!");
          Toastify({ text: "Text copied to clipboard!", duration: 2000, gravity: "top", position: "center", backgroundColor: "#6366f1", stopOnFocus: true }).showToast();
        });
      });
      copyPolishedButton.addEventListener("click", () => {
        navigator.clipboard.writeText(polishedNote.textContent).then(() => {
          showCopyStatus("Text copied to clipboard!");
          Toastify({ text: "Text copied to clipboard!", duration: 2000, gravity: "top", position: "center", backgroundColor: "#6366f1", stopOnFocus: true }).showToast();
        });
      });

      function drawWaveform() {
        analyserNode.getByteTimeDomainData(dataArray);
        canvasCtx.fillStyle = "#e5e7eb";
        canvasCtx.fillRect(0, 0, waveform.width, waveform.height);
        canvasCtx.lineWidth = 2;
        canvasCtx.strokeStyle = "#6366f1";
        canvasCtx.beginPath();

        const sliceWidth = waveform.width / dataArray.length;
        let x = 0;

        for (let i = 0; i < dataArray.length; i++) {
          const v = dataArray[i] / 128.0;
          const y = (v * waveform.height) / 2;

          if (i === 0) {
            canvasCtx.moveTo(x, y);
          } else {
            canvasCtx.lineTo(x, y);
          }

          x += sliceWidth;
        }

        canvasCtx.lineTo(waveform.width, waveform.height / 2);
        canvasCtx.stroke();
        animationId = requestAnimationFrame(drawWaveform);
      }
      
      intervalInput.addEventListener("change", () => {
        let val = parseInt(intervalInput.value, 10);
        if (isNaN(val) || val < 2) val = 2;
        if (val > 60) val = 60;
        chunkInterval = val;
        intervalInput.value = val;
      });

      // --- Chunked Recording Logic (UNCHANGED from app14) ---
      recordBtn.addEventListener("click", async () => {
        if (!checkApiKey()) return;
        if (isChunkRecording) return;

        try {
          const displayStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
          stream = new MediaStream(displayStream.getAudioTracks());
          displayStream.getVideoTracks().forEach((track) => track.stop());
          startChunkRecording();
          recordBtn.style.display = "none";
          stopBtn.style.display = "inline-block";
        } catch (err) {
          Toastify({
            text: "Could not access screen share. Ensure audio sharing is enabled.",
            duration: 3000,
            gravity: "top",
            position: "center",
            backgroundColor: "#ef4444",
            stopOnFocus: true,
          }).showToast();
        }
      });

      stopBtn.addEventListener("click", () => {
        stopChunkRecording();
        recordBtn.style.display = "inline-block";
        stopBtn.style.display = "none";
      });

      function startChunkRecording() {
        isChunkRecording = true;
        waveform.style.display = "block";
        waveform.width = waveform.offsetWidth;
        waveform.height = waveform.offsetHeight;

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        source = audioContext.createMediaStreamSource(stream);
        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 2048;
        dataArray = new Uint8Array(analyserNode.fftSize);
        source.connect(analyserNode);
        drawWaveform();

        startNewMediaRecorderChunk();
      }

      function stopChunkRecording() {
        isChunkRecording = false;
        if (chunkTimer) clearTimeout(chunkTimer);

        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.onstop = () => {
            if (audioChunks && audioChunks.length > 0) {
              processAudioChunkIfNotSilent(new Blob(audioChunks, { type: 'audio/webm' }));
              audioChunks = [];
            }
            if (stream) stream.getTracks().forEach(track => track.stop());
            if (audioContext) audioContext.close();
            cancelAnimationFrame(animationId);
            waveform.style.display = "none";
            canvasCtx.clearRect(0, 0, waveform.width, waveform.height);
          };
          mediaRecorder.stop();
        } else {
          if (stream) stream.getTracks().forEach(track => track.stop());
          if (audioContext) audioContext.close();
          cancelAnimationFrame(animationId);
          waveform.style.display = "none";
          canvasCtx.clearRect(0, 0, waveform.width, waveform.height);
        }
      }

      function startNewMediaRecorderChunk() {
        audioChunks = [];
        let mimeType = 'audio/webm';
        if (!MediaRecorder.isTypeSupported(mimeType)) {
          mimeType = '';
        }
        const options = mimeType ? { mimeType } : {};
        mediaRecorder = new MediaRecorder(stream, options);

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) audioChunks.push(event.data);
        };

        mediaRecorder.onstop = () => {
          if (!isChunkRecording) return;
          processAudioChunkIfNotSilent(new Blob(audioChunks, { type: 'audio/webm' }));
          if (isChunkRecording) {
            startNewMediaRecorderChunk();
          }
        };

        mediaRecorder.start();
        chunkTimer = setTimeout(() => {
          if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
          }
        }, chunkInterval * 1000);
      }

      async function processAudioChunk(audioBlob, retryCount = 0) {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) return;
        const reader = new FileReader();
        reader.readAsDataURL(audioBlob);
        reader.onloadend = async () => {
          const base64 = reader.result.split(',')[1];
          const payload = {
            contents: [
              {
                role: "user",
                parts: [
                  { text: "Generate a complete, detailed transcript of this audio. If no audio content is detected, just reply 'No audio'." },
                  { inlineData: { mimeType: "audio/webm", data: base64 } }
                ]
              }
            ]
          };
          try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            const result = await response.json();
            if (!response.ok || result.error) {
              throw new Error(`Gemini API error: ${result.error?.message || response.status}`);
            }
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text || '';
            if (text) {
              let current = rawTranscription.innerText.trim();
              rawTranscription.innerText = (current ? current + "\n" : "") + text;
              updateTabs();
            }
          } catch (err) {
            if (retryCount < 3) {
              console.warn(`[processAudioChunk] Error, retrying (${retryCount + 1}/3) in 0.5s...`, err);
              setTimeout(() => processAudioChunk(audioBlob, retryCount + 1), 500);
            } else {
              console.error("[processAudioChunk] Failed after 3 retries:", err);
              Toastify({
                text: "Error processing audio chunk after 3 retries.",
                duration: 2000,
                gravity: "top",
                position: "center",
                backgroundColor: "#ef4444",
                stopOnFocus: true,
              }).showToast();
            }
          }
        };
      }

      // --- Polish Button Logic (MERGED) ---
      polishButton.addEventListener("click", async () => {
        const apiKey = apiKeyInput.value.trim();
        const text = rawTranscription.textContent.trim();
        if (!apiKey || !text) {
          Toastify({
            text: "No raw text to polish.",
            duration: 2000,
            gravity: "top",
            position: "center",
            backgroundColor: "#ef4444",
            stopOnFocus: true,
          }).showToast();
          return;
        }
        const polishPayload = {
          contents: [
            {
              role: "user",
              parts: [
                {
                  text: `You are a highly skilled meeting assistant and language model trained to extract clarity from noisy or imperfect transcripts. I will provide you with a raw meeting transcript that may contain errors due to background noise, speech accents, or imperfect transcription tools.

Strategy:
Your carry out the work in two step, and print the result of each step:

Step 1. Transcript Clean-Up
Correct any obvious misheard words or phrases caused by background noise or strong accents. The transcript will put some "No audio" in transcript if that portion didn't contains sound. You can ignore "No audio", it is not meeting content.

Ensure names, company jargon, and common phrases are interpreted sensibly.
If a section is inaudible or unclear, mark it as [unclear].

Step 2: Meeting note taking
2.1. Structured Summary
Under a heading called ‚ÄúSummary of Discussion‚Äù, group the transcript into key themes or topics. For each topic:
Provide a concise 2‚Äì3 sentence summary.
Identify the speakers involved if possible.

2.2. Action Items
Under a heading called ‚ÄúAction Items‚Äù, extract clear follow-up tasks.
Each action item should include:
‚úÖ Task Description
üßë Responsible Person
üìÖ Deadline (if any)
üóí Context (optional if clarification is helpful)

2.3. Decisions Made
Under a heading ‚ÄúKey Decisions‚Äù, list any decisions agreed upon during the meeting. Include:
‚úÖ What was decided
üßë Who agreed or led the decision
üìÜ Timeframe or impact (if discussed)

2.4. Open Questions
Under a heading ‚ÄúUnresolved Questions‚Äù, identify any questions that were raised but not resolved.
These could become future agenda items.

If any section of the input transcript is ambiguous, use your best judgment to infer meaning‚Äîbut mark speculative areas with [unclear].

Output Format:
[1] Transcript CleanUp:
 {cleanuped Transcript content}

[2]Meeting notes:
 {The result in step 2 of meeting notes taking}

Here is the raw transcript:

${text}`
                }
              ]
            }
          ]
        };

        async function sendPolishRequest(retryCount = 0) {
          try {
            const polishResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(polishPayload)
            });
            const polishResult = await polishResponse.json();
            if (!polishResponse.ok || polishResult.error) {
              throw new Error(`Gemini API error: ${polishResult.error?.message || polishResponse.status}`);
            }
            const polishText = polishResult.candidates?.[0]?.content?.parts?.[0]?.text || '[No polish result]';
            currentPolishedMarkdown = polishText; // UPDATED: Store raw markdown
            polishedNote.innerHTML = marked.parse(polishText); // Render it
            updateTabs();
            tabPolished.click();
          } catch (err) {
            if (retryCount < 3) {
              console.warn(`[polishButton] Error, retrying (${retryCount + 1}/3) in 0.5s...`, err);
              setTimeout(() => sendPolishRequest(retryCount + 1), 500);
            } else {
              console.error("[polishButton] Failed after 3 retries:", err);
              Toastify({
                text: "Error polishing text after 3 retries.",
                duration: 2000,
                gravity: "top",
                position: "center",
                backgroundColor: "#ef4444",
                stopOnFocus: true,
              }).showToast();
            }
          }
        }
        sendPolishRequest();
      });

      // --- ADDED: Meeting Notes UI functions from app10 ---
      function renderMeetingNotesList() {
        const notes = loadMeetingNotes();
        const list = document.getElementById('meetingNotesList');
        list.innerHTML = '';
        notes.forEach(note => {
          const li = document.createElement('li');
          li.className = "mb-2 flex items-center gap-2";
          li.innerHTML = `
            <span class="font-semibold" contenteditable="true"
                  onblur="saveNoteTitle('${note.id}', this.textContent)"
                  onkeydown="if (event.key === 'Enter') { this.blur(); return false; }">${note.title || '[Untitled]'}</span>
            <button onclick="viewNote('${note.id}')" class="px-2 py-0.5 bg-green-500 text-white text-xs rounded">View</button>
            <button onclick="copyPolishedNote('${note.id}')" class="px-2 py-0.5 bg-blue-400 text-white text-xs rounded">Copy</button>
            <button onclick="exportNote('${note.id}')" class="px-2 py-0.5 bg-gray-400 text-white text-xs rounded">Export</button>
            <button onclick="deleteNoteUI('${note.id}')" class="px-2 py-0.5 bg-red-500 text-xs rounded text-white">Delete</button>
          `;
          list.appendChild(li);
        });
      }

      function viewNote(noteId) {
        const notes = loadMeetingNotes();
        const note = notes.find(n => n.id === noteId);
        if (note && note.polishedNote) {
            const newTab = window.open();
            const noteContent = note.polishedNote;
            const noteTitle = note.title || 'Meeting Note';
            newTab.document.write(`
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>${noteTitle}</title>
                <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"><\/script>
                <link rel="preconnect" href="https://fonts.googleapis.com">
                <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
                <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
                <style>
                    body { font-family: 'Inter', sans-serif; line-height: 1.7; color: #374151; background-color: #f9fafb; margin: 0; padding: 2rem; }
                    .container { max-width: 800px; margin: 0 auto; background-color: #ffffff; padding: 2rem 3rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
                    h1, h2, h3 { color: #1f2937; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.3em; margin-top: 1.5em;}
                    h1 { font-size: 2em;}
                    h2 { font-size: 1.5em;}
                    h3 { font-size: 1.25em;}
                    code { background-color: #f3f4f6; padding: 3px 6px; border-radius: 4px; font-family: 'Courier New', Courier, monospace; }
                    pre { background-color: #f3f4f6; padding: 1rem; border-radius: 4px; overflow-x: auto; }
                    blockquote { border-left: 4px solid #d1d5db; padding-left: 1rem; color: #4b5563; margin-left: 0; }
                    ul, ol { padding-left: 1.5rem; }
                    li { margin-bottom: 0.5rem; }
                    a { color: #3b82f6; text-decoration: none; }
                    a:hover { text-decoration: underline; }
                </style>
            </head>
            <body>
                <div id="content" class="container"></div>
                <script>
                    const markdownContent = \`${noteContent.replace(/`/g, '\\`')}\`;
                    marked.use({ breaks: true });
                    document.getElementById('content').innerHTML = marked.parse(markdownContent);
                <\/script>
            </body>
            </html>
            `);
            newTab.document.close();
        } else {
             Toastify({ text: "No polished note content to view.", duration: 2000, gravity: "top", position: "center", backgroundColor: "#ef4444", stopOnFocus: true }).showToast();
        }
      }

      function saveNoteTitle(noteId, newTitle) {
        const notes = loadMeetingNotes();
        const note = notes.find(n => n.id === noteId);
        if (note) {
          note.title = newTitle;
          saveAllNotes(notes);
          Toastify({
            text: "Note title updated!",
            duration: 2000,
            gravity: "top",
            position: "center",
            backgroundColor: "#10b981",
            stopOnFocus: true,
          }).showToast();
        }
      }

      function deleteNoteUI(noteId) {
        if(confirm("Are you sure you want to permanently delete this note? This action cannot be undone.")){
            deleteNote(noteId);
            renderMeetingNotesList();
            Toastify({
              text: "Note deleted.",
              duration: 2000,
              gravity: "top",
              position: "center",
              backgroundColor: "#ef4444",
              stopOnFocus: true,
            }).showToast();
        }
      }

      document.getElementById('exportAllNotesBtn').onclick = exportAllNotes;
      document.getElementById('addNoteBtn').onclick = function() {
        const now = new Date();
        const pad = n => n.toString().padStart(2, '0');
        const months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
        const title = `${now.getFullYear()}${months[now.getMonth()]}${pad(now.getDate())}-${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
        saveOrUpdateNote({
          id: Date.now().toString(),
          title,
          rawTranscript: rawTranscription.textContent || "",
          polishedNote: currentPolishedMarkdown || "",
          tags: [],
          customFields: {}
        });
        renderMeetingNotesList();
      };

      function isSilent(audioBuffer, threshold = 0.01) {
        // audioBuffer is a Float32Array
        let sum = 0;
        for (let i = 0; i < audioBuffer.length; i++) {
          sum += audioBuffer[i] * audioBuffer[i];
        }
        const rms = Math.sqrt(sum / audioBuffer.length);
        return rms < threshold;
      }

      function processAudioChunkIfNotSilent(audioBlob) {
        // Use Web Audio API to decode and check for silence
        const reader = new FileReader();
        reader.onloadend = function() {
          const arrayBuffer = reader.result;
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          ctx.decodeAudioData(arrayBuffer, (audioBuffer) => {
            // Use only the first channel for silence detection
            const channelData = audioBuffer.getChannelData(0);
            if (isSilent(channelData)) {
              console.log("[processAudioChunkIfNotSilent] Skipped silent chunk.");
              ctx.close();
              return;
            }
            ctx.close();
            processAudioChunk(audioBlob);
          }, (err) => {
            // If decoding fails, send anyway
            console.warn("[processAudioChunkIfNotSilent] decodeAudioData failed, sending anyway.", err);
            processAudioChunk(audioBlob);
            ctx.close();
          });
        };
        reader.readAsArrayBuffer(audioBlob);
      }
    </script>
    <script>lucide.createIcons();</script>
  </body>
</html>