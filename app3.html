<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Basic Version</title>
    <style>
        body {
    background-color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin: 0;
    font-family: Arial, sans-serif;
    height: 100vh;
    overflow: hidden;
}
        #title {
            margin-top: 10px;
            font-size: 24px;
            font-weight: bold;
        }
        #container {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-top: 10px;
        }
        canvas {
            border: 1px solid black;
            background-color: #f9f9f9;
        }
        #side-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #nextCanvas {
            border: 1px solid black;
            background-color: #f0f0f0;
        }
        #score {
            font-size: 18px;
            font-weight: bold;
        }
        #speed-controls, #start-pause-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
        }
        #controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
        }
        #controls button {
            padding: 9px 18px;
            font-size: 21px;
        }
        button {
            padding: 6px 12px;
            font-size: 14px;
        }
        button {
        touch-action: manipulation;
        -webkit-touch-callout: none;
    }
</style>
</head>
<body>
    <h2 id="title">Tetris</h2>
    <select id="language-select">
        <option value="en" selected>English</option>
        <option value="zh">中文</option>
    </select>
    <div id="container">
        <canvas id="gameCanvas" width="300" height="600"></canvas>
        <div id="side-panel">
            <canvas id="nextCanvas" width="120" height="120"></canvas>
            <div id="score">Score: 0</div>
            <div id="speed-controls">
                <button id="speed-up-btn">Increase Speed</button>
                <button id="speed-down-btn">Decrease Speed</button>
            </div>
            <div id="start-pause-controls">
                <button id="start-btn">Start Game</button>
                <button id="pause-btn">Pause Game</button>
            </div>
        </div>
    </div>
    <div id="controls">
        <button id="rotate-btn">Rotate</button>
        <button id="left-btn">Left</button>
        <button id="right-btn">Right</button>
        <button id="drop-btn">Hard Drop</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');

        const COLS = 10, ROWS = 20, BLOCK_SIZE = 30;
        const colors = ["red", "green", "blue", "yellow", "cyan", "magenta", "orange"];
        const shapes = [
            [[1, 1, 1, 1]], [[1, 1], [1, 1]],
            [[0, 1, 0], [1, 1, 1]], [[1, 0, 0], [1, 1, 1]],
            [[0, 0, 1], [1, 1, 1]], [[0, 1, 1], [1, 1, 0]], [[1, 1, 0], [0, 1, 1]]
        ];

        let board, current, next, interval, dropInterval = 500, isPaused = false, gameOver = false, score = 0;

        const texts = {
            en: {
                title: "Tetris",
                score: "Score: ",
                start: "Start Game",
                pause: "Pause Game",
                resume: "Resume Game",
                speedUp: "Increase Speed",
                speedDown: "Decrease Speed",
                rotate: "Rotate",
                left: "Left",
                right: "Right",
                drop: "Hard Drop",
                gameOver: "Game Over! Score: "
            },
            zh: {
                title: "俄罗斯方块",
                score: "得分: ",
                start: "开始游戏",
                pause: "暂停游戏",
                resume: "继续游戏",
                speedUp: "级别速度增加",
                speedDown: "级别速度减少",
                rotate: "旋转",
                left: "左移",
                right: "右移",
                drop: "直接落下",
                gameOver: "游戏结束，得分: "
            }
        };

        let lang = 'en';
        const langSelect = document.getElementById('language-select');
        langSelect.onchange = () => {
            lang = langSelect.value;
            updateTexts();
        };

        function updateTexts() {
            document.getElementById('title').innerText = texts[lang].title;
            document.getElementById('score').innerText = texts[lang].score + score;
            document.getElementById('start-btn').innerText = texts[lang].start;
            document.getElementById('pause-btn').innerText = isPaused ? texts[lang].resume : texts[lang].pause;
            document.getElementById('speed-up-btn').innerText = texts[lang].speedUp;
            document.getElementById('speed-down-btn').innerText = texts[lang].speedDown;
            document.getElementById('rotate-btn').innerText = texts[lang].rotate;
            document.getElementById('left-btn').innerText = texts[lang].left;
            document.getElementById('right-btn').innerText = texts[lang].right;
            document.getElementById('drop-btn').innerText = texts[lang].drop;
        }

        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);
                ctx.stroke();
            }
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) drawBlock(c, r, colors[board[r][c] - 1]);
                }
            }
        }

        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = "black";
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }

        function drawNext() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            const size = 20;
            nextCtx.strokeStyle = '#ccc';
            for (let x = 0; x <= 5; x++) {
                nextCtx.beginPath();
                nextCtx.moveTo(x * size, 0);
                nextCtx.lineTo(x * size, 120);
                nextCtx.stroke();
            }
            for (let y = 0; y <= 6; y++) {
                nextCtx.beginPath();
                nextCtx.moveTo(0, y * size);
                nextCtx.lineTo(120, y * size);
                nextCtx.stroke();
            }
            next.shape.forEach((row, r) => row.forEach((val, c) => {
                if (val) {
                    nextCtx.fillStyle = colors[next.color - 1];
                    nextCtx.fillRect(c * size, r * size, size, size);
                    nextCtx.strokeStyle = 'black';
                    nextCtx.strokeRect(c * size, r * size, size, size);
                }
            }));
        }

        function newPiece() {
            const index = Math.floor(Math.random() * shapes.length);
            return { shape: shapes[index], color: index + 1, x: Math.floor((COLS - shapes[index][0].length) / 2), y: 0 };
        }

        function canMove(p, offsetX, offsetY, newShape = p.shape) {
            for (let r = 0; r < newShape.length; r++) {
                for (let c = 0; c < newShape[r].length; c++) {
                    if (newShape[r][c]) {
                        let x = p.x + c + offsetX, y = p.y + r + offsetY;
                        if (x < 0 || x >= COLS || y >= ROWS || (y >= 0 && board[y][x])) return false;
                    }
                }
            }
            return true;
        }

        function mergePiece(p) {
            p.shape.forEach((row, r) => row.forEach((val, c) => {
                if (val && p.y + r >= 0) board[p.y + r][p.x + c] = p.color;
            }));
        }

        function clearLines() {
            let lines = 0;
            board = board.filter(row => {
                if (row.every(cell => cell)) { lines++; return false; }
                return true;
            });
            while (board.length < ROWS) board.unshift(Array(COLS).fill(0));
            score += lines * 100;
            document.getElementById('score').innerText = texts[lang].score + score;
        }

        function drop() {
            if (gameOver || isPaused) return;
            if (canMove(current, 0, 1)) {
                current.y++;
            } else {
                mergePiece(current);
                clearLines();
                if (current.y <= 0) {
                    gameOver = true;
                    clearInterval(interval);
                    alert(texts[lang].gameOver + score);
                    location.reload();
                    return;
                }
                current = next;
                next = newPiece();
                drawNext();
            }
            redraw();
        }

        function redraw() {
            drawBoard();
            drawPiece(current);
        }

        function drawPiece(p) {
            p.shape.forEach((row, r) => row.forEach((val, c) => {
                if (val) drawBlock(p.x + c, p.y + r, colors[p.color - 1]);
            }));
        }

        function startGame() {
            board = createBoard();
            current = newPiece();
            next = newPiece();
            isPaused = false;
            gameOver = false;
            score = 0;
            dropInterval = 500;
            updateTexts();
            drawNext();
            clearInterval(interval);
            interval = setInterval(drop, dropInterval);
            redraw();
        }

        function togglePause() {
            if (gameOver) return;
            isPaused = !isPaused;
            updateTexts();
            if (isPaused) clearInterval(interval);
            else interval = setInterval(drop, dropInterval);
        }

        document.getElementById('start-btn').onclick = startGame;
        document.getElementById('pause-btn').onclick = togglePause;
        document.getElementById('speed-up-btn').onclick = () => {
            dropInterval = Math.max(100, dropInterval - 100);
            if (!isPaused) { clearInterval(interval); interval = setInterval(drop, dropInterval); }
        };
        document.getElementById('speed-down-btn').onclick = () => {
            dropInterval += 100;
            if (!isPaused) { clearInterval(interval); interval = setInterval(drop, dropInterval); }
        };

        document.getElementById('rotate-btn').onclick = () => { if (!isPaused && canMove(current, 0, 0)) { rotate(current); redraw(); } };
        document.getElementById('left-btn').onclick = () => { if (!isPaused && canMove(current, -1, 0)) { current.x--; redraw(); } };
        document.getElementById('right-btn').onclick = () => { if (!isPaused && canMove(current, 1, 0)) { current.x++; redraw(); } };
        document.getElementById('drop-btn').onclick = () => {
            if (!isPaused) { while (canMove(current, 0, 1)) current.y++; redraw(); }
        };

        function rotate(p) {
            let newShape = p.shape[0].map((_, i) => p.shape.map(row => row[i])).reverse();
            if (canMove(p, 0, 0, newShape)) p.shape = newShape;
        }

        document.addEventListener('keydown', e => {
            if (gameOver || isPaused) return;
            if (e.key === 'ArrowLeft') { if (canMove(current, -1, 0)) current.x--; }
            else if (e.key === 'ArrowRight') { if (canMove(current, 1, 0)) current.x++; }
            else if (e.key === 'ArrowDown') { if (canMove(current, 0, 1)) current.y++; }
            else if (e.key === 'ArrowUp') rotate(current);
            else if (e.key.toLowerCase() === 'd') { while (canMove(current, 0, 1)) current.y++; }
            redraw();
        });

        updateTexts();

        // Touch event support for mobile swipe gestures
let touchStartX = 0;
let touchStartY = 0;

canvas.addEventListener('touchstart', function(e) {
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
}, false);

canvas.addEventListener('touchend', function(e) {
    const touch = e.changedTouches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;
    if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 30 && canMove(current, 1, 0)) { current.x++; redraw(); } // Swipe Right
        else if (dx < -30 && canMove(current, -1, 0)) { current.x--; redraw(); } // Swipe Left
    } else {
        if (dy > 30) { // Swipe Down
            if (canMove(current, 0, 1)) current.y++;
            redraw();
        } else if (dy < -30) { // Swipe Up
            rotate(current);
            redraw();
        }
    }
}, false);

window.addEventListener('resize', resizeCanvas);
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth * 0.9, 300);
            const scale = maxWidth / 300;
            canvas.style.width = maxWidth + 'px';
            canvas.style.height = (600 * scale) + 'px';
        }
        resizeCanvas();
    </script>
</body>
</html>
