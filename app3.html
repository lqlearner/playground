<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Tetris Basic</title>
    <style>
        body {
            background-color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        canvas {
            border: 1px solid black;
            background-color: #f9f9f9;
        }
        #side-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #nextCanvas {
            border: 1px solid black;
            background-color: #f0f0f0;
        }
        #score {
            font-size: 18px;
            font-weight: bold;
        }
        #speed-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #controls {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        button {
            padding: 6px 12px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <select id="language-select">
        <option value="zh">中文</option>
        <option value="en">English</option>
    </select>
    <div id="container">
        <canvas id="gameCanvas" width="300" height="600"></canvas>
        <div id="side-panel">
            <canvas id="nextCanvas" width="120" height="120"></canvas>
            <div id="score">得分: 0</div>
            <div id="speed-controls">
                <button id="speed-up-btn">级别速度增加</button>
                <button id="speed-down-btn">级别速度减少</button>
            </div>
        </div>
    </div>
    <div id="controls">
        <button id="start-btn">开始游戏</button>
        <button id="pause-btn">暂停游戏</button>
        <button id="rotate-btn">旋转</button>
        <button id="left-btn">左移</button>
        <button id="right-btn">右移</button>
        <button id="drop-btn">直接落下</button>
    </div>

    <script>
        const texts = {
            zh: {
                start: "开始游戏",
                pause: "暂停游戏",
                resume: "继续游戏",
                rotate: "旋转",
                left: "左移",
                right: "右移",
                drop: "直接落下",
                speedUp: "级别速度增加",
                speedDown: "级别速度减少",
                score: "得分: ",
                gameOver: "游戏结束，得分: "
            },
            en: {
                start: "Start",
                pause: "Pause",
                resume: "Resume",
                rotate: "Rotate",
                left: "Left",
                right: "Right",
                drop: "Hard Drop",
                speedUp: "Speed Up",
                speedDown: "Speed Down",
                score: "Score: ",
                gameOver: "Game Over! Score: "
            }
        };

        let currentLang = 'en';

        document.getElementById('language-select').value = currentLang;
document.getElementById('language-select').onchange = function() {
            currentLang = this.value;
            updateTexts();
        };

        function updateTexts() {
            const t = texts[currentLang];
            document.getElementById('start-btn').innerText = t.start;
            document.getElementById('pause-btn').innerText = isPaused ? t.resume : t.pause;
            document.getElementById('rotate-btn').innerText = t.rotate;
            document.getElementById('left-btn').innerText = t.left;
            document.getElementById('right-btn').innerText = t.right;
            document.getElementById('drop-btn').innerText = t.drop;
            document.getElementById('speed-up-btn').innerText = t.speedUp;
            document.getElementById('speed-down-btn').innerText = t.speedDown;
            document.getElementById('score').innerText = t.score + score;
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        const COLS = 10, ROWS = 20, BLOCK_SIZE = 30;
        const NEXT_BLOCK_SIZE = 20;
        const colors = ["red", "green", "blue", "yellow", "cyan", "magenta", "orange"];
        const shapes = [
            [[1, 1, 1, 1]],
            [[1, 1], [1, 1]],
            [[0,1,0],[1,1,1]],
            [[1,0,0],[1,1,1]],
            [[0,0,1],[1,1,1]],
            [[0,1,1],[1,1,0]],
            [[1,1,0],[0,1,1]]
        ];

        let board, current, nextPiece, interval, isPaused = false, gameOver = false, score = 0;
        let dropInterval = 500;

        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        function drawGrid() {
            ctx.strokeStyle = "#ddd";
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);
                ctx.stroke();
            }
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) drawBlock(c, r, colors[board[r][c] - 1]);
                }
            }
        }

        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = "black";
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }

        function drawNext() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            let shape = nextPiece.shape;
            let color = colors[nextPiece.color - 1];
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        nextCtx.fillStyle = color;
                        nextCtx.fillRect(c * NEXT_BLOCK_SIZE + 20, r * NEXT_BLOCK_SIZE + 20, NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);
                        nextCtx.strokeStyle = "black";
                        nextCtx.strokeRect(c * NEXT_BLOCK_SIZE + 20, r * NEXT_BLOCK_SIZE + 20, NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);
                    }
                }
            }
        }

        function generatePiece() {
            const index = Math.floor(Math.random() * shapes.length);
            return {
                shape: shapes[index],
                color: index + 1,
                x: Math.floor((COLS - shapes[index][0].length) / 2),
                y: 0
            };
        }

        function spawnNewPiece() {
            current = nextPiece;
            nextPiece = generatePiece();
            drawNext();
        }

        function canMove(p, offsetX, offsetY, newShape = p.shape) {
            for (let r = 0; r < newShape.length; r++) {
                for (let c = 0; c < newShape[r].length; c++) {
                    if (newShape[r][c]) {
                        let newX = p.x + c + offsetX;
                        let newY = p.y + r + offsetY;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX])) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function mergePiece(p) {
            for (let r = 0; r < p.shape.length; r++) {
                for (let c = 0; c < p.shape[r].length; c++) {
                    if (p.shape[r][c]) {
                        let newY = p.y + r;
                        if (newY >= 0) board[newY][p.x + c] = p.color;
                    }
                }
            }
        }

        function clearLines() {
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    board.splice(r, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    r++;
                }
            }
            if (linesCleared > 0) {
                score += linesCleared * 100;
                document.getElementById('score').innerText = texts[currentLang].score + score;
            }
        }

        function rotate(p) {
            let newShape = p.shape[0].map((_, i) => p.shape.map(row => row[i])).reverse();
            if (canMove(p, 0, 0, newShape)) p.shape = newShape;
        }

        function drop() {
            if (gameOver || isPaused) return;
            if (canMove(current, 0, 1)) {
                current.y++;
            } else {
                mergePiece(current);
                clearLines();
                if (current.y <= 0) {
                    gameOver = true;
                    clearInterval(interval);
                    setTimeout(() => {
                        alert(texts[currentLang].gameOver + score);
                        location.reload();
                    }, 100);
                    return;
                }
                spawnNewPiece();
            }
            redraw();
        }

        function redraw() {
            drawBoard();
            drawPiece(current);
        }

        function drawPiece(p) {
            for (let r = 0; r < p.shape.length; r++) {
                for (let c = 0; c < p.shape[r].length; c++) {
                    if (p.shape[r][c]) drawBlock(p.x + c, p.y + r, colors[p.color - 1]);
                }
            }
        }

        function startGame() {
            board = createBoard();
            nextPiece = generatePiece();
            spawnNewPiece();
            gameOver = false;
            isPaused = false;
            score = 0;
            document.getElementById('score').innerText = texts[currentLang].score + 0;
            clearInterval(interval);
            interval = setInterval(drop, dropInterval);
            redraw();
        }

        function togglePause() {
            if (gameOver) return;
            isPaused = !isPaused;
            document.getElementById('pause-btn').innerText = isPaused ? texts[currentLang].resume : texts[currentLang].pause;
            if (isPaused) {
                clearInterval(interval);
            } else {
                interval = setInterval(drop, dropInterval);
            }
        }

        function adjustSpeed(change) {
            dropInterval = Math.max(100, dropInterval + change);
            clearInterval(interval);
            interval = setInterval(drop, dropInterval);
        }

        document.getElementById('start-btn').onclick = startGame;
        document.getElementById('pause-btn').onclick = togglePause;
        document.getElementById('rotate-btn').onclick = () => { if (!gameOver && !isPaused) { rotate(current); redraw(); } };
        document.getElementById('left-btn').onclick = () => { if (!gameOver && !isPaused && canMove(current, -1, 0)) { current.x--; redraw(); } };
        document.getElementById('right-btn').onclick = () => { if (!gameOver && !isPaused && canMove(current, 1, 0)) { current.x++; redraw(); } };
        document.getElementById('drop-btn').onclick = () => {
            if (!gameOver && !isPaused) {
                while (canMove(current, 0, 1)) current.y++;
                drop();
            }
        };
        document.getElementById('speed-up-btn').onclick = () => adjustSpeed(-100);
        document.getElementById('speed-down-btn').onclick = () => adjustSpeed(100);

        updateTexts();
document.addEventListener('keydown', e => {
            if (gameOver || isPaused) return;
            if (e.key === 'ArrowLeft' && canMove(current, -1, 0)) current.x--;
            else if (e.key === 'ArrowRight' && canMove(current, 1, 0)) current.x++;
            else if (e.key === 'ArrowDown' && canMove(current, 0, 1)) current.y++;
            else if (e.key === 'ArrowUp') rotate(current);
            else if (e.key.toLowerCase() === 'd') {
                while (canMove(current, 0, 1)) current.y++;
                drop();
            }
            redraw();
        });
    </script>
</body>
</html>
